name: PR Auto Labeler

on:
    pull_request:
        types: [opened, synchronize, reopened]

permissions:
    contents: read
    pull-requests: write

jobs:
    label-by-files:
        runs-on: ubuntu-latest
        steps:
            - uses: actions/labeler@v5
              with:
                  repo-token: "${{ secrets.GITHUB_TOKEN }}"
                  configuration-path: .github/labeler.yml
                  sync-labels: true

    label-by-size:
        runs-on: ubuntu-latest
        steps:
            - name: Label by size
              uses: codelytv/pr-size-labeler@v1
              with:
                  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
                  xs_label: "size/xs"
                  xs_max_size: 10
                  s_label: "size/s"
                  s_max_size: 50
                  m_label: "size/m"
                  m_max_size: 200
                  l_label: "size/l"
                  l_max_size: 500
                  xl_label: "size/xl"
                  fail_if_xl: "false"

    label-by-type:
        runs-on: ubuntu-latest
        steps:
            - name: Label by PR type
              uses: actions/github-script@v7
              with:
                  script: |
                      const title = context.payload.pull_request.title.toLowerCase();
                      const labels = [];

                      // Type-based labels
                      if (title.includes('feat:') || title.includes('feature:')) {
                        labels.push('type: feature');
                      }
                      if (title.includes('fix:') || title.includes('bugfix:')) {
                        labels.push('type: bug');
                      }
                      if (title.includes('docs:')) {
                        labels.push('type: documentation');
                      }
                      if (title.includes('refactor:')) {
                        labels.push('type: refactor');
                      }
                      if (title.includes('test:')) {
                        labels.push('type: test');
                      }
                      if (title.includes('chore:')) {
                        labels.push('type: chore');
                      }
                      if (title.includes('perf:')) {
                        labels.push('type: performance');
                      }
                      if (title.includes('ci:')) {
                        labels.push('type: ci/cd');
                      }

                      // Priority labels based on keywords
                      if (title.includes('urgent') || title.includes('critical') || title.includes('hotfix')) {
                        labels.push('priority: high');
                      }

                      // Draft PR
                      if (context.payload.pull_request.draft) {
                        labels.push('status: draft');
                      }

                      if (labels.length > 0) {
                        await github.rest.issues.addLabels({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          issue_number: context.issue.number,
                          labels: labels
                        });
                        console.log(`Added labels: ${labels.join(', ')}`);
                      }
